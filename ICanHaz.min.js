/*!
ICanHaz.js version 0.10 -- by @HenrikJoreteg
More info at: http://icanhazjs.com
FORKED to https://github.com/elmo61/ICanHaz.js to able to enable overwritting of templates & lazy loading
*/
(function () {
    var a = function () { var b = Object.prototype.toString; Array.isArray = Array.isArray || function (k) { return b.call(k) == "[object Array]"; }; var j = String.prototype.trim, c; if (j) { c = function (k) { return k == null ? "" : j.call(k); }; } else { var d, h; if ((/\S/).test("\xA0")) { d = /^[\s\xA0]+/; h = /[\s\xA0]+$/; } else { d = /^\s+/; h = /\s+$/; } c = function (k) { return k == null ? "" : k.toString().replace(d, "").replace(h, ""); }; } var g = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }; function i(k) { return String(k).replace(/&(?!\w+;)|[<>"']/g, function (m) { return g[m] || m; }); } var f = {}; var e = function () { }; e.prototype = { otag: "{{", ctag: "}}", pragmas: {}, buffer: [], pragmas_implemented: { "IMPLICIT-ITERATOR": true }, context: {}, render: function (o, n, m, p) { if (!p) { this.context = n; this.buffer = []; } if (!this.includes("", o)) { if (p) { return o; } else { this.send(o); return; } } o = this.render_pragmas(o); var k = this.render_section(o, n, m); if (k === false) { k = this.render_tags(o, n, m, p); } if (p) { return k; } else { this.sendLines(k); } }, send: function (k) { if (k !== "") { this.buffer.push(k); } }, sendLines: function (n) { if (n) { var k = n.split("\n"); for (var m = 0; m < k.length; m++) { this.send(k[m]); } } }, render_pragmas: function (k) { if (!this.includes("%", k)) { return k; } var n = this; var m = this.getCachedRegex("render_pragmas", function (p, o) { return new RegExp(p + "%([\\w-]+) ?([\\w]+=[\\w]+)?" + o, "g"); }); return k.replace(m, function (q, o, p) { if (!n.pragmas_implemented[o]) { throw ({ message: "This implementation of mustache doesn't understand the '" + o + "' pragma" }); } n.pragmas[o] = {}; if (p) { var r = p.split("="); n.pragmas[o][r[0]] = r[1]; } return ""; }); }, render_partial: function (k, n, m) { k = c(k); if (!m || m[k] === undefined) { throw ({ message: "unknown_partial '" + k + "'" }); } if (!n || typeof n[k] != "object") { return this.render(m[k], n, m, true); } return this.render(m[k], n[k], m, true); }, render_section: function (n, m, k) { if (!this.includes("#", n) && !this.includes("^", n)) { return false; } var p = this; var o = this.getCachedRegex("render_section", function (r, q) { return new RegExp("^([\\s\\S]*?)" + r + "(\\^|\\#)\\s*(.+)\\s*" + q + "\n*([\\s\\S]*?)" + r + "\\/\\s*\\3\\s*" + q + "\\s*([\\s\\S]*)$", "g"); }); return n.replace(o, function (t, x, w, s, u, r) { var z = x ? p.render_tags(x, m, k, true) : "", v = r ? p.render(r, m, k, true) : "", q, y = p.find(s, m); if (w === "^") { if (!y || Array.isArray(y) && y.length === 0) { q = p.render(u, m, k, true); } else { q = ""; } } else { if (w === "#") { if (Array.isArray(y)) { q = p.map(y, function (A) { return p.render(u, p.create_context(A), k, true); }).join(""); } else { if (p.is_object(y)) { q = p.render(u, p.create_context(y), k, true); } else { if (typeof y == "function") { q = y.call(m, u, function (A) { return p.render(A, m, k, true); }); } else { if (y) { q = p.render(u, m, k, true); } else { q = ""; } } } } } } return z + q + v; }); }, render_tags: function (t, k, n, p) { var o = this; var s = function () { return o.getCachedRegex("render_tags", function (w, v) { return new RegExp(w + "(=|!|>|&|\\{|%)?([^#\\^]+?)\\1?" + v + "+", "g"); }); }; var q = s(); var r = function (x, v, w) { switch (v) { case "!": return ""; case "=": o.set_delimiters(w); q = s(); return ""; case ">": return o.render_partial(w, k, n); case "{": case "&": return o.find(w, k); default: return i(o.find(w, k)); } }; var u = t.split("\n"); for (var m = 0; m < u.length; m++) { u[m] = u[m].replace(q, r, this); if (!p) { this.send(u[m]); } } if (p) { return u.join("\n"); } }, set_delimiters: function (m) { var k = m.split(" "); this.otag = this.escape_regex(k[0]); this.ctag = this.escape_regex(k[1]); }, escape_regex: function (m) { if (!arguments.callee.sRE) { var k = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"]; arguments.callee.sRE = new RegExp("(\\" + k.join("|\\") + ")", "g"); } return m.replace(arguments.callee.sRE, "\\$1"); }, find: function (n, o) { n = c(n); function m(q) { return q === false || q === 0 || q; } var p; if (n.match(/([a-z_]+)\./ig)) { var k = this.walk_context(n, o); if (m(k)) { p = k; } } else { if (m(o[n])) { p = o[n]; } else { if (m(this.context[n])) { p = this.context[n]; } } } if (typeof p == "function") { return p.apply(o); } if (p !== undefined) { return p; } return ""; }, walk_context: function (k, m) { var p = k.split("."); var o = (m[p[0]] != undefined) ? m : this.context; var n = o[p.shift()]; while (n != undefined && p.length > 0) { o = n; n = n[p.shift()]; } if (typeof n == "function") { return n.apply(o); } return n; }, includes: function (m, k) { return k.indexOf(this.otag + m) != -1; }, create_context: function (m) { if (this.is_object(m)) { return m; } else { var n = "."; if (this.pragmas["IMPLICIT-ITERATOR"]) { n = this.pragmas["IMPLICIT-ITERATOR"].iterator; } var k = {}; k[n] = m; return k; } }, is_object: function (k) { return k && typeof k == "object"; }, map: function (p, n) { if (typeof p.map == "function") { return p.map(n); } else { var o = []; var k = p.length; for (var m = 0; m < k; m++) { o.push(n(p[m])); } return o; } }, getCachedRegex: function (m, p) { var o = f[this.otag]; if (!o) { o = f[this.otag] = {}; } var k = o[this.ctag]; if (!k) { k = o[this.ctag] = {}; } var n = k[m]; if (!n) { n = k[m] = p(this.otag, this.ctag); } return n; } }; return ({ name: "mustache.js", version: "0.4.0", to_html: function (n, k, m, p) { var o = new e(); if (p) { o.send = p; } o.render(n, k || {}, m); if (!p) { return o.buffer.join("\n"); } } }); } ();
    /*!
    ICanHaz.js -- by @HenrikJoreteg
    */
    (function () { function b(d) { if ("".trim) { return d.trim(); } else { return d.replace(/^\s+/, "").replace(/\s+$/, ""); } } var c = { VERSION: "0.10", templates: {}, $: (typeof window !== "undefined") ? window.jQuery || window.Zepto || null : null, addTemplate: function (d, f) { if (typeof d === "object") { for (var e in d) { this.addTemplate(e, d[e]); } return; } if (c[d] && !c.templates[d]) { console.error("Invalid name: " + d + "."); } else { c.templates[d] = f; c[d] = function (i, h) { i = i || {}; var g = a.to_html(c.templates[d], i, c.templates); return (c.$ && !h) ? c.$(g) : g; }; } }, clearAll: function () { for (var d in c.templates) { delete c[d]; } c.templates = {}; }, refresh: function () { c.clearAll(); c.grabTemplates(); }, grabTemplates: function () { var g, d = document.getElementsByTagName("script"), e, f = []; for (g = 0, l = d.length; g < l; g++) { e = d[g]; if (e && e.innerHTML && e.id && (e.type === "text/html" || e.type === "text/x-icanhaz")) { c.addTemplate(e.id, b(e.innerHTML)); f.unshift(e); } } for (g = 0, l = f.length; g < l; g++) { f[g].parentNode.removeChild(f[g]); } }, build: function (d, e) { if (c[d]) { } else { $.ajax({ url: ApplicationPath + "/API/Templates.svc/?TemplateName=" + d, async: false, success: function (f) { c.addTemplate(d, JSON.parse(f).HTML); }, error: function (g, h, f) { AjaxError2(g, h, f); } }); } return c[d](e); } }; if (typeof require !== "undefined") { module.exports = c; } else { window.ich = c; } if (typeof document !== "undefined") { if (c.$) { c.$(function () { c.grabTemplates(); }); } else { document.addEventListener("DOMContentLoaded", function () { c.grabTemplates(); }, true); } } })();
})();